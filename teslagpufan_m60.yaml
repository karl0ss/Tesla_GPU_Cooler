substitutions:
  friendly_name: TeslaM60Fan
  gpu1_topic: sensors2mqtt/nvidia-smi/00000000_06_00_0
  gpu2_topic: sensors2mqtt/nvidia-smi/00000000_07_00_0
  temp_low: "60.0"
  temp_high: "80.0"
  fan_min: "5.0"
  fan_max: "100.0"

esphome:
  name: "teslam60fan"
  friendly_name: ${friendly_name}

  on_boot:
    priority: -100
    then:
      - output.set_level:
          id: fan_speed
          level: 1.0
      - globals.set:
          id: fan_speed_percent
          value: "100.0"
      - logger.log: "Safe-boot: fan set to 100% until GPU data received."

esp8266:
  board: esp01_1m

logger:
  level: INFO

web_server:
  port: 80

ota:
  password: "17300c7bac4a847d2b255aca0f4620e3"

captive_portal:

wifi:
  ssid: Hudgell-Wifi
  password: !secret wifi_password
  reboot_timeout: 1min
  manual_ip:
    static_ip: 192.168.4.105
    gateway: 192.168.4.1
    subnet: 255.255.255.0

  ap:
    ssid: "TeslaM60Fan-Esp12E"
    password: "S0tDmOp8vq0n"

mqtt:
  broker: 192.168.4.196
  username: mosquitto
  password: !secret mqtt_pass
  reboot_timeout: 10min
  on_disconnect:
    then:
      - lambda: |-
          ESP_LOGW("main", "MQTT disconnected — forcing fan to 100%%");
          id(fan_speed_percent) = 100.0;
          id(fan_speed).set_level(1.0);

# ───────────────────────────────────────────────────────────────
# Globals
globals:
  - id: fan_speed_percent
    type: float
    initial_value: '0.0'
  - id: gpu_max_temp
    type: float
    initial_value: '0.0'
  - id: manual_override
    type: bool
    initial_value: 'false'
  - id: last_update
    type: uint32_t
    initial_value: '0'
  - id: json_error_count
    type: int
    initial_value: '0'

# ───────────────────────────────────────────────────────────────
# Switches
switch:
  - platform: restart
    name: "${friendly_name} Restart"

  - platform: template
    name: "Manual Fan Override"
    id: manual_override_switch
    lambda: |-
      return id(manual_override);
    turn_on_action:
      - globals.set:
          id: manual_override
          value: "true"
      - logger.log: "Manual Fan Override enabled"
    turn_off_action:
      - globals.set:
          id: manual_override
          value: "false"
      - logger.log: "Manual Fan Override disabled"
    restore_mode: ALWAYS_OFF

# ───────────────────────────────────────────────────────────────
# Text Sensors
text_sensor:
  - platform: wifi_info
    ip_address:
      name: ${friendly_name} IP Address

  - platform: template
    name: ${friendly_name} Uptime
    id: uptime_human
    icon: mdi:clock-start

  - platform: mqtt_subscribe
    name: "GPU 1 Temp"
    internal: true
    id: gpu_1_temp
    topic: ${gpu1_topic}

  - platform: mqtt_subscribe
    name: "GPU 2 Temp"
    internal: true
    id: gpu_2_temp
    topic: ${gpu2_topic}

# ───────────────────────────────────────────────────────────────
# Sensors
sensor:
  - platform: wifi_signal
    name: WiFi Strength
    update_interval: 30s

  - platform: template
    name: "GPU 1 Temperature"
    id: gpu_1_temp_sensor
    unit_of_measurement: "°C"
    update_interval: never

  - platform: template
    name: "GPU 2 Temperature"
    id: gpu_2_temp_sensor
    unit_of_measurement: "°C"
    update_interval: never

  - platform: template
    name: "GPU Maximum Temperature"
    id: gpu_max_temp_sensor
    unit_of_measurement: "°C"
    lambda: |-
      return id(gpu_max_temp);
    update_interval: 5s

  - platform: template
    name: "Current Fan Speed"
    lambda: 'return round(id(fan_speed_percent));'
    unit_of_measurement: '%'
    update_interval: 5s

  - platform: template
    name: "JSON Parse Errors"
    lambda: "return id(json_error_count);"
    update_interval: 30s

  - platform: pulse_counter
    pin: GPIO0
    name: Fan RPM
    id: fan_RPM_pulse
    unit_of_measurement: 'RPM'
    filters:
      - multiply: 0.5
    count_mode:
      rising_edge: INCREMENT
      falling_edge: DISABLE
    update_interval: 10s

# ───────────────────────────────────────────────────────────────
# Output
output:
  - platform: esp8266_pwm
    id: fan_speed
    pin: GPIO02
    frequency: "25000 Hz"
    min_power: 5%
    max_power: 100%

# ───────────────────────────────────────────────────────────────
# Fan Override
number:
  - platform: template
    name: "Fan Speed Override"
    id: fan_speed_override
    max_value: 100.0
    min_value: 0.0
    step: 5
    mode: slider
    on_value:
      then:
        - globals.set:
            id: manual_override
            value: "true"
        - output.set_level:
            id: fan_speed
            level: !lambda "return x / 100.0;"
        - lambda: |-
            id(fan_speed_percent) = x;

# ───────────────────────────────────────────────────────────────
# Intervals
interval:
  - interval: 5s
    then:
      # GPU 1 parsing
      - lambda: |-
          if (id(gpu_1_temp).state.length() > 0) {
            std::string json_str = id(gpu_1_temp).state;
            DynamicJsonDocument doc(1024);
            DeserializationError error = deserializeJson(doc, json_str);
            if (error || !doc.containsKey("temperature.gpu")) {
              id(json_error_count)++;
              ESP_LOGW("main", "GPU1 JSON parse fail (%d)", id(json_error_count));
              id(gpu_1_temp_sensor).publish_state(NAN);
            } else {
              float t = doc["temperature.gpu"];
              id(gpu_1_temp_sensor).publish_state(t);
              id(last_update) = millis();
            }
          }

      # GPU 2 parsing
      - lambda: |-
          if (id(gpu_2_temp).state.length() > 0) {
            std::string json_str = id(gpu_2_temp).state;
            DynamicJsonDocument doc(1024);
            DeserializationError error = deserializeJson(doc, json_str);
            if (error || !doc.containsKey("temperature.gpu")) {
              id(json_error_count)++;
              ESP_LOGW("main", "GPU2 JSON parse fail (%d)", id(json_error_count));
              id(gpu_2_temp_sensor).publish_state(NAN);
            } else {
              float t = doc["temperature.gpu"];
              id(gpu_2_temp_sensor).publish_state(t);
              id(last_update) = millis();
            }
          }

  - interval: 1s
    then:
      - lambda: |-
          if (!id(manual_override)) {
            // Failsafe: if no data in 15s
            if ((millis() - id(last_update)) > 15000) {
              ESP_LOGW("main", "No GPU data in 15s — forcing fan to 100%%");
              id(fan_speed).set_level(1.0);
              id(fan_speed_percent) = 100.0;
              return;
            }

            // Determine max temperature
            float t1 = id(gpu_1_temp_sensor).state;
            float t2 = id(gpu_2_temp_sensor).state;
            float max_temp = std::max(t1, t2);
            id(gpu_max_temp) = max_temp;
            id(adjust_fan_speed).execute();
          }

# ───────────────────────────────────────────────────────────────
# Script: auto fan control
script:
  - id: adjust_fan_speed
    mode: queued
    then:
      - lambda: |-
          float temp = id(gpu_max_temp);
          if (isnan(temp)) return;

          float fanSpeedPercent;
          if (temp < ${temp_low}) {
            fanSpeedPercent = ${fan_min};
          } else if (temp >= ${temp_low} && temp < ${temp_high}) {
            fanSpeedPercent = ((temp - ${temp_low}) / (${temp_high} - ${temp_low})) *
                              (${fan_max} - ${fan_min}) + ${fan_min};
          } else {
            fanSpeedPercent = ${fan_max};
          }

          // Deadband 3% to prevent rapid PWM changes
          float delta = fabs(id(fan_speed_percent) - fanSpeedPercent);
          if (delta > 3.0) {
            id(fan_speed).set_level(fanSpeedPercent / 100.0);
            id(fan_speed_percent) = fanSpeedPercent;
            ESP_LOGI("fan", "Temp: %.1f°C → Fan: %.1f%%", temp, fanSpeedPercent);
          }
